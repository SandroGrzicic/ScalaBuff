// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: enum.proto

package resources.generated

object ComputerPeripherals extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val KEYBOARD = new EnumVal { val name = "KEYBOARD"; val id = 1 }
	val MOUSE = new EnumVal { val name = "MOUSE"; val id = 2 }

	val KEYBOARD_VALUE = 1
	val MOUSE_VALUE = 2

	def valueOf(id: Int) = id match {
		case 1 => KEYBOARD
		case 2 => MOUSE
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class MyPeripherals (
	primary_Peripheral: Option[ComputerPeripherals.EnumVal] = Some(ComputerPeripherals.KEYBOARD),
	secondary_Peripheral: Option[ComputerPeripherals.EnumVal] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MyPeripherals]
	with net.sandrogrzicic.scalabuff.Parser[MyPeripherals] {

	def setPrimary_Peripheral(_f: ComputerPeripherals.EnumVal) = copy(primary_Peripheral = Some(_f))
	def setSecondary_Peripheral(_f: ComputerPeripherals.EnumVal) = copy(secondary_Peripheral = Some(_f))

	def clearPrimary_Peripheral = copy(primary_Peripheral = None)
	def clearSecondary_Peripheral = copy(secondary_Peripheral = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (primary_Peripheral.isDefined) output.writeEnum(1, primary_Peripheral.get)
		if (secondary_Peripheral.isDefined) output.writeEnum(2, secondary_Peripheral.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		if (primary_Peripheral.isDefined) __size += computeEnumSize(1, primary_Peripheral.get)
		if (secondary_Peripheral.isDefined) __size += computeEnumSize(2, secondary_Peripheral.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MyPeripherals = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __primary_Peripheral: Option[ComputerPeripherals.EnumVal] = primary_Peripheral
		var __secondary_Peripheral: Option[ComputerPeripherals.EnumVal] = secondary_Peripheral

		def __newMerged = MyPeripherals(
			__primary_Peripheral,
			__secondary_Peripheral
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __primary_Peripheral = Some(try { ComputerPeripherals.valueOf(in.readEnum()) } catch { case e: Exception => Some(ComputerPeripherals.KEYBOARD).get })
			case 16 => __secondary_Peripheral = Some(ComputerPeripherals.valueOf(in.readEnum()))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MyPeripherals) = {
		MyPeripherals(
			m.primary_Peripheral.orElse(primary_Peripheral),
			m.secondary_Peripheral.orElse(secondary_Peripheral)
		)
	}

	def getDefaultInstanceForType = MyPeripherals.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = {
		val indent0 = "\n" + ("\t" * indent)
		val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
		val sb = StringBuilder.newBuilder
		sb
			.append("{")
			if (`primary_Peripheral`.isDefined) { sb.append(indent1).append("\"primary_Peripheral\": ").append("\"").append(`primary_Peripheral`.get).append("\"").append(',') }
			if (`secondary_Peripheral`.isDefined) { sb.append(indent1).append("\"secondary_Peripheral\": ").append("\"").append(`secondary_Peripheral`.get).append("\"").append(',') }
		if (sb.last.equals(',')) sb.length -= 1
		sb.append(indent0).append("}")
		sb.toString()
	}

}

object MyPeripherals {
	@scala.beans.BeanProperty val defaultInstance = new MyPeripherals()

	def parseFrom(data: Array[Byte]): MyPeripherals = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MyPeripherals = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MyPeripherals = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MyPeripherals = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MyPeripherals] = defaultInstance.mergeDelimitedFromStream(stream)

	val PRIMARY_PERIPHERAL_FIELD_NUMBER = 1
	val SECONDARY_PERIPHERAL_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MyPeripherals) = defaultInstance.mergeFrom(prototype)

}
object TestNames extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val TEST1_1 = new EnumVal { val name = "TEST1_1"; val id = 1 }
	val TEST11 = new EnumVal { val name = "TEST11"; val id = 2 }

	val TEST1_1_VALUE = 1
	val TEST11_VALUE = 2

	def valueOf(id: Int) = id match {
		case 1 => TEST1_1
		case 2 => TEST11
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class MyTestNames (
	first_Name: Option[TestNames.EnumVal] = Some(TestNames.TEST1_1),
	second_Name: Option[TestNames.EnumVal] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MyTestNames]
	with net.sandrogrzicic.scalabuff.Parser[MyTestNames] {

	def setFirst_Name(_f: TestNames.EnumVal) = copy(first_Name = Some(_f))
	def setSecond_Name(_f: TestNames.EnumVal) = copy(second_Name = Some(_f))

	def clearFirst_Name = copy(first_Name = None)
	def clearSecond_Name = copy(second_Name = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (first_Name.isDefined) output.writeEnum(1, first_Name.get)
		if (second_Name.isDefined) output.writeEnum(2, second_Name.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		if (first_Name.isDefined) __size += computeEnumSize(1, first_Name.get)
		if (second_Name.isDefined) __size += computeEnumSize(2, second_Name.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MyTestNames = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __first_Name: Option[TestNames.EnumVal] = first_Name
		var __second_Name: Option[TestNames.EnumVal] = second_Name

		def __newMerged = MyTestNames(
			__first_Name,
			__second_Name
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __first_Name = Some(try { TestNames.valueOf(in.readEnum()) } catch { case e: Exception => Some(TestNames.TEST1_1).get })
			case 16 => __second_Name = Some(TestNames.valueOf(in.readEnum()))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MyTestNames) = {
		MyTestNames(
			m.first_Name.orElse(first_Name),
			m.second_Name.orElse(second_Name)
		)
	}

	def getDefaultInstanceForType = MyTestNames.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = {
		val indent0 = "\n" + ("\t" * indent)
		val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
		val sb = StringBuilder.newBuilder
		sb
			.append("{")
			if (`first_Name`.isDefined) { sb.append(indent1).append("\"first_Name\": ").append("\"").append(`first_Name`.get).append("\"").append(',') }
			if (`second_Name`.isDefined) { sb.append(indent1).append("\"second_Name\": ").append("\"").append(`second_Name`.get).append("\"").append(',') }
		if (sb.last.equals(',')) sb.length -= 1
		sb.append(indent0).append("}")
		sb.toString()
	}

}

object MyTestNames {
	@scala.beans.BeanProperty val defaultInstance = new MyTestNames()

	def parseFrom(data: Array[Byte]): MyTestNames = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MyTestNames = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MyTestNames = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MyTestNames = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MyTestNames] = defaultInstance.mergeDelimitedFromStream(stream)

	val FIRST_NAME_FIELD_NUMBER = 1
	val SECOND_NAME_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MyTestNames) = defaultInstance.mergeFrom(prototype)

}
final case class Outer (
	inner_Required: Outer.Inner.EnumVal = Outer.Inner._UNINITIALIZED,
	inner_Optional: Option[Outer.Inner.EnumVal] = Some(Outer.Inner.FIRST),
	inner_Repeated: scala.collection.immutable.Seq[Outer.Inner.EnumVal] = Vector.empty[Outer.Inner.EnumVal]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Outer]
	with net.sandrogrzicic.scalabuff.Parser[Outer] {

	def setInner_Optional(_f: Outer.Inner.EnumVal) = copy(inner_Optional = Some(_f))
	def setInner_Repeated(_i: Int, _v: Outer.Inner.EnumVal) = copy(inner_Repeated = inner_Repeated.updated(_i, _v))
	def addInner_Repeated(_f: Outer.Inner.EnumVal) = copy(inner_Repeated = inner_Repeated :+ _f)
	def addAllInner_Repeated(_f: Outer.Inner.EnumVal*) = copy(inner_Repeated = inner_Repeated ++ _f)
	def addAllInner_Repeated(_f: TraversableOnce[Outer.Inner.EnumVal]) = copy(inner_Repeated = inner_Repeated ++ _f)

	def clearInner_Optional = copy(inner_Optional = None)
	def clearInner_Repeated = copy(inner_Repeated = Vector.empty[Outer.Inner.EnumVal])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeEnum(1, inner_Required)
		if (inner_Optional.isDefined) output.writeEnum(2, inner_Optional.get)
		var index_inner_Repeated = 0
		while (index_inner_Repeated < inner_Repeated.length) {
			output.writeEnum(3, inner_Repeated(index_inner_Repeated))
			index_inner_Repeated += 1
		}
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeEnumSize(1, inner_Required)
		if (inner_Optional.isDefined) __size += computeEnumSize(2, inner_Optional.get)
		var index_inner_Repeated = 0
		while (index_inner_Repeated < inner_Repeated.length) {
			__size += computeEnumSize(3, inner_Repeated(index_inner_Repeated))
			index_inner_Repeated += 1
		}

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Outer = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __inner_Required: Outer.Inner.EnumVal = Outer.Inner._UNINITIALIZED
		var __inner_Optional: Option[Outer.Inner.EnumVal] = inner_Optional
		val __inner_Repeated: scala.collection.mutable.Buffer[Outer.Inner.EnumVal] = inner_Repeated.toBuffer

		def __newMerged = Outer(
			__inner_Required,
			__inner_Optional,
			Vector(__inner_Repeated: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __inner_Required = Outer.Inner.valueOf(in.readEnum())
			case 16 => __inner_Optional = Some(try { Outer.Inner.valueOf(in.readEnum()) } catch { case e: Exception => Some(Outer.Inner.FIRST).get })
			case 24 => __inner_Repeated += Outer.Inner.valueOf(in.readEnum())
			case 26 => 
				val length = in.readRawVarint32()
				val limit = in.pushLimit(length)
				while (in.getBytesUntilLimit() > 0) {
					__inner_Repeated += Outer.Inner.valueOf(in.readEnum())
				}
				in.popLimit(limit)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Outer) = {
		Outer(
			m.inner_Required,
			m.inner_Optional.orElse(inner_Optional),
			inner_Repeated ++ m.inner_Repeated
		)
	}

	def getDefaultInstanceForType = Outer.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = {
		val indent0 = "\n" + ("\t" * indent)
		val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
		val sb = StringBuilder.newBuilder
		sb
			.append("{")
			sb.append(indent1).append("\"inner_Required\": ").append("\"").append(`inner_Required`).append("\"").append(',')
			if (`inner_Optional`.isDefined) { sb.append(indent1).append("\"inner_Optional\": ").append("\"").append(`inner_Optional`.get).append("\"").append(',') }
			sb.append(indent1).append("\"inner_Repeated\": [").append(indent2).append(`inner_Repeated`.map("\"" + _ + "\"").mkString(", " + indent2)).append(indent1).append(']').append(',')
		if (sb.last.equals(',')) sb.length -= 1
		sb.append(indent0).append("}")
		sb.toString()
	}

}

object Outer {
	@scala.beans.BeanProperty val defaultInstance = new Outer()

	def parseFrom(data: Array[Byte]): Outer = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Outer = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Outer = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Outer = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Outer] = defaultInstance.mergeDelimitedFromStream(stream)

	val INNER_REQUIRED_FIELD_NUMBER = 1
	val INNER_OPTIONAL_FIELD_NUMBER = 2
	val INNER_REPEATED_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Outer) = defaultInstance.mergeFrom(prototype)

	object Inner extends net.sandrogrzicic.scalabuff.Enum {
		sealed trait EnumVal extends Value
		val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

		val FIRST = new EnumVal { val name = "FIRST"; val id = 1 }
		val SECOND = new EnumVal { val name = "SECOND"; val id = 2 }

		val FIRST_VALUE = 1
		val SECOND_VALUE = 2

		def valueOf(id: Int) = id match {
			case 1 => FIRST
			case 2 => SECOND
			case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
		}
		val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
			def findValueByNumber(id: Int): EnumVal = valueOf(id)
		}
	}

}
final case class OuterDuplicate (
	inner_Required: OuterDuplicate.Inner.EnumVal = OuterDuplicate.Inner._UNINITIALIZED,
	inner_Optional: Option[OuterDuplicate.Inner.EnumVal] = Some(OuterDuplicate.Inner.SECOND),
	inner_Repeated: scala.collection.immutable.Seq[OuterDuplicate.Inner.EnumVal] = Vector.empty[OuterDuplicate.Inner.EnumVal]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[OuterDuplicate]
	with net.sandrogrzicic.scalabuff.Parser[OuterDuplicate] {

	def setInner_Optional(_f: OuterDuplicate.Inner.EnumVal) = copy(inner_Optional = Some(_f))
	def setInner_Repeated(_i: Int, _v: OuterDuplicate.Inner.EnumVal) = copy(inner_Repeated = inner_Repeated.updated(_i, _v))
	def addInner_Repeated(_f: OuterDuplicate.Inner.EnumVal) = copy(inner_Repeated = inner_Repeated :+ _f)
	def addAllInner_Repeated(_f: OuterDuplicate.Inner.EnumVal*) = copy(inner_Repeated = inner_Repeated ++ _f)
	def addAllInner_Repeated(_f: TraversableOnce[OuterDuplicate.Inner.EnumVal]) = copy(inner_Repeated = inner_Repeated ++ _f)

	def clearInner_Optional = copy(inner_Optional = None)
	def clearInner_Repeated = copy(inner_Repeated = Vector.empty[OuterDuplicate.Inner.EnumVal])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeEnum(1, inner_Required)
		if (inner_Optional.isDefined) output.writeEnum(2, inner_Optional.get)
		var index_inner_Repeated = 0
		while (index_inner_Repeated < inner_Repeated.length) {
			output.writeEnum(3, inner_Repeated(index_inner_Repeated))
			index_inner_Repeated += 1
		}
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeEnumSize(1, inner_Required)
		if (inner_Optional.isDefined) __size += computeEnumSize(2, inner_Optional.get)
		var index_inner_Repeated = 0
		while (index_inner_Repeated < inner_Repeated.length) {
			__size += computeEnumSize(3, inner_Repeated(index_inner_Repeated))
			index_inner_Repeated += 1
		}

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): OuterDuplicate = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __inner_Required: OuterDuplicate.Inner.EnumVal = OuterDuplicate.Inner._UNINITIALIZED
		var __inner_Optional: Option[OuterDuplicate.Inner.EnumVal] = inner_Optional
		val __inner_Repeated: scala.collection.mutable.Buffer[OuterDuplicate.Inner.EnumVal] = inner_Repeated.toBuffer

		def __newMerged = OuterDuplicate(
			__inner_Required,
			__inner_Optional,
			Vector(__inner_Repeated: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __inner_Required = OuterDuplicate.Inner.valueOf(in.readEnum())
			case 16 => __inner_Optional = Some(try { OuterDuplicate.Inner.valueOf(in.readEnum()) } catch { case e: Exception => Some(OuterDuplicate.Inner.SECOND).get })
			case 24 => __inner_Repeated += OuterDuplicate.Inner.valueOf(in.readEnum())
			case 26 => 
				val length = in.readRawVarint32()
				val limit = in.pushLimit(length)
				while (in.getBytesUntilLimit() > 0) {
					__inner_Repeated += OuterDuplicate.Inner.valueOf(in.readEnum())
				}
				in.popLimit(limit)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: OuterDuplicate) = {
		OuterDuplicate(
			m.inner_Required,
			m.inner_Optional.orElse(inner_Optional),
			inner_Repeated ++ m.inner_Repeated
		)
	}

	def getDefaultInstanceForType = OuterDuplicate.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = {
		val indent0 = "\n" + ("\t" * indent)
		val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
		val sb = StringBuilder.newBuilder
		sb
			.append("{")
			sb.append(indent1).append("\"inner_Required\": ").append("\"").append(`inner_Required`).append("\"").append(',')
			if (`inner_Optional`.isDefined) { sb.append(indent1).append("\"inner_Optional\": ").append("\"").append(`inner_Optional`.get).append("\"").append(',') }
			sb.append(indent1).append("\"inner_Repeated\": [").append(indent2).append(`inner_Repeated`.map("\"" + _ + "\"").mkString(", " + indent2)).append(indent1).append(']').append(',')
		if (sb.last.equals(',')) sb.length -= 1
		sb.append(indent0).append("}")
		sb.toString()
	}

}

object OuterDuplicate {
	@scala.beans.BeanProperty val defaultInstance = new OuterDuplicate()

	def parseFrom(data: Array[Byte]): OuterDuplicate = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): OuterDuplicate = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): OuterDuplicate = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): OuterDuplicate = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[OuterDuplicate] = defaultInstance.mergeDelimitedFromStream(stream)

	val INNER_REQUIRED_FIELD_NUMBER = 1
	val INNER_OPTIONAL_FIELD_NUMBER = 2
	val INNER_REPEATED_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: OuterDuplicate) = defaultInstance.mergeFrom(prototype)

	object Inner extends net.sandrogrzicic.scalabuff.Enum {
		sealed trait EnumVal extends Value
		val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

		val FIRST = new EnumVal { val name = "FIRST"; val id = 1 }
		val SECOND = new EnumVal { val name = "SECOND"; val id = 2 }

		val FIRST_VALUE = 1
		val SECOND_VALUE = 2

		def valueOf(id: Int) = id match {
			case 1 => FIRST
			case 2 => SECOND
			case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
		}
		val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
			def findValueByNumber(id: Int): EnumVal = valueOf(id)
		}
	}

}
final case class OuterEnumContainer (
	inner_Message: OuterEnumContainer.InnerEnumContainer = OuterEnumContainer.InnerEnumContainer.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[OuterEnumContainer]
	with net.sandrogrzicic.scalabuff.Parser[OuterEnumContainer] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, inner_Message)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, inner_Message)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): OuterEnumContainer = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __inner_Message: OuterEnumContainer.InnerEnumContainer = OuterEnumContainer.InnerEnumContainer.defaultInstance

		def __newMerged = OuterEnumContainer(
			__inner_Message
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __inner_Message = readMessage[OuterEnumContainer.InnerEnumContainer](in, __inner_Message, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: OuterEnumContainer) = {
		OuterEnumContainer(
			m.inner_Message
		)
	}

	def getDefaultInstanceForType = OuterEnumContainer.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = {
		val indent0 = "\n" + ("\t" * indent)
		val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
		val sb = StringBuilder.newBuilder
		sb
			.append("{")
			sb.append(indent1).append("\"inner_Message\": ").append(`inner_Message`.toJson(indent + 1)).append(',')
		if (sb.last.equals(',')) sb.length -= 1
		sb.append(indent0).append("}")
		sb.toString()
	}

}

object OuterEnumContainer {
	@scala.beans.BeanProperty val defaultInstance = new OuterEnumContainer()

	def parseFrom(data: Array[Byte]): OuterEnumContainer = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): OuterEnumContainer = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): OuterEnumContainer = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): OuterEnumContainer = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[OuterEnumContainer] = defaultInstance.mergeDelimitedFromStream(stream)

	val INNER_MESSAGE_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: OuterEnumContainer) = defaultInstance.mergeFrom(prototype)

	final case class InnerEnumContainer (
		some_Enum: InnerEnumContainer.SomeEnum.EnumVal = InnerEnumContainer.SomeEnum._UNINITIALIZED
	) extends com.google.protobuf.GeneratedMessageLite
		with com.google.protobuf.MessageLite.Builder
		with net.sandrogrzicic.scalabuff.Message[InnerEnumContainer]
		with net.sandrogrzicic.scalabuff.Parser[InnerEnumContainer] {



		def writeTo(output: com.google.protobuf.CodedOutputStream) {
			output.writeEnum(1, some_Enum)
		}

		def getSerializedSize = {
			import com.google.protobuf.CodedOutputStream._
			var __size = 0
			__size += computeEnumSize(1, some_Enum)

			__size
		}

		def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): InnerEnumContainer = {
			import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
			var __some_Enum: InnerEnumContainer.SomeEnum.EnumVal = InnerEnumContainer.SomeEnum._UNINITIALIZED

			def __newMerged = InnerEnumContainer(
				__some_Enum
			)
			while (true) in.readTag match {
				case 0 => return __newMerged
				case 8 => __some_Enum = InnerEnumContainer.SomeEnum.valueOf(in.readEnum())
				case default => if (!in.skipField(default)) return __newMerged
			}
			null
		}

		def mergeFrom(m: InnerEnumContainer) = {
			InnerEnumContainer(
				m.some_Enum
			)
		}

		def getDefaultInstanceForType = InnerEnumContainer.defaultInstance
		def clear = getDefaultInstanceForType
		def isInitialized = true
		def build = this
		def buildPartial = this
		def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
		override def getParserForType = this
		def newBuilderForType = getDefaultInstanceForType
		def toBuilder = this
		def toJson(indent: Int = 0): String = {
			val indent0 = "\n" + ("\t" * indent)
			val (indent1, indent2) = (indent0 + "\t", indent0 + "\t\t")
			val sb = StringBuilder.newBuilder
			sb
				.append("{")
				sb.append(indent1).append("\"some_Enum\": ").append("\"").append(`some_Enum`).append("\"").append(',')
			if (sb.last.equals(',')) sb.length -= 1
			sb.append(indent0).append("}")
			sb.toString()
		}

	}

	object InnerEnumContainer {
		@scala.beans.BeanProperty val defaultInstance = new InnerEnumContainer()

		def parseFrom(data: Array[Byte]): InnerEnumContainer = defaultInstance.mergeFrom(data)
		def parseFrom(data: Array[Byte], offset: Int, length: Int): InnerEnumContainer = defaultInstance.mergeFrom(data, offset, length)
		def parseFrom(byteString: com.google.protobuf.ByteString): InnerEnumContainer = defaultInstance.mergeFrom(byteString)
		def parseFrom(stream: java.io.InputStream): InnerEnumContainer = defaultInstance.mergeFrom(stream)
		def parseDelimitedFrom(stream: java.io.InputStream): Option[InnerEnumContainer] = defaultInstance.mergeDelimitedFromStream(stream)

		val SOME_ENUM_FIELD_NUMBER = 1

		def newBuilder = defaultInstance.newBuilderForType
		def newBuilder(prototype: InnerEnumContainer) = defaultInstance.mergeFrom(prototype)

		object SomeEnum extends net.sandrogrzicic.scalabuff.Enum {
			sealed trait EnumVal extends Value
			val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

			val VALUE_1 = new EnumVal { val name = "VALUE_1"; val id = 0 }
			val VALUE_2 = new EnumVal { val name = "VALUE_2"; val id = 1 }
			val VALUE_3 = new EnumVal { val name = "VALUE_3"; val id = 2 }

			val VALUE_1_VALUE = 0
			val VALUE_2_VALUE = 1
			val VALUE_3_VALUE = 2

			def valueOf(id: Int) = id match {
				case 0 => VALUE_1
				case 1 => VALUE_2
				case 2 => VALUE_3
				case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
			}
			val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
				def findValueByNumber(id: Int): EnumVal = valueOf(id)
			}
		}

	}
}

object EnumTest {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

	private val fromBinaryHintMap = collection.immutable.HashMap[String, Array[Byte] ⇒ com.google.protobuf.GeneratedMessageLite](
		 "MyPeripherals" -> (bytes ⇒ MyPeripherals.parseFrom(bytes)),
		 "MyTestNames" -> (bytes ⇒ MyTestNames.parseFrom(bytes)),
		 "Outer" -> (bytes ⇒ Outer.parseFrom(bytes)),
		 "OuterDuplicate" -> (bytes ⇒ OuterDuplicate.parseFrom(bytes)),
		 "OuterEnumContainer" -> (bytes ⇒ OuterEnumContainer.parseFrom(bytes))
	)

	def deserializePayload(payload: Array[Byte], payloadType: String): com.google.protobuf.GeneratedMessageLite = {
		fromBinaryHintMap.get(payloadType) match {
			case Some(f) ⇒ f(payload)
			case None    ⇒ throw new IllegalArgumentException(s"unimplemented deserialization of message payload of type [${payloadType}]")
		}
	}
}
